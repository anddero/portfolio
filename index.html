<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>

    <!-- CSS Section -->
    <style>
    </style>
</head>

<body>

<!-- Header Section -->
<header>
</header>

<!-- Main Content Section -->
<main>

    <input type="file" id="importLogInput" name="Import">
    <p id="importLogInputMsg"></p>

    <h2>Log</h2>
    <table id="logTable">
    </table>

    <button id="exportLogButton">Export</button>

</main>

<!-- JavaScript Section -->
<script>

    // CONSTANTS

    const ALL_POSSIBLE_JSON_FIELDS = [
        "date",
        "action",
        "platform",
        "assetType",
        "assetCode",
        "unitCount",
        "currency",
        "unitValue",
        "totalValue",
        "feeValue",
        "grossValue",
        "netValue",
        "taxValue",
        "fromPlatform",
        "toPlatform",
        "fromCurrency",
        "fromValue",
        "toCurrency",
        "toValue",
        "fromToCoefficient",
        "notes"
    ];

    const ALL_POSSIBLE_ACTIONS = [
        "Check",
        "NewPlatform",
        "Buy",
        "Deposit",
        "Dividend",
        "CurrencyConversion",
        "PublicToPrivateShareConversion",
        "Other",
        "Transfer",
        "Sell",
        "Interest"
    ];

    // STATE

    let gActivityList = []; // Raw activity JSON
    let gActivityErrorMap = new Map(); // Errors in the activity JSON, where key is activity index and value is error message
    let gPortfolioState = {}; // Portfolio structured state such as overview, individual asset summaries, etc

    // EVENT BINDINGS

    document.getElementById('importLogInput').addEventListener('change', onImportLogInputChange);
    document.getElementById('exportLogButton').addEventListener('click', onExportLogButtonClick);

    // EVENT HANDLERS

    function setImportLogInputMsg(message, isError) {
        document.getElementById("importLogInputMsg").innerText = message;
        document.getElementById("importLogInputMsg").style = `color: ${isError ? "red" : "green"};`;
    }

    // Reset all global state, process and validate the given file, set the global state and update DOM
    async function onImportLogInputChange(event) {
        console.log("onImportLogInputChange");

        // New state, initially cleared
        let activityList = [];
        let activityErrorMap = new Map();
        let portfolioState = {};
        let msg = { "text": "Something went wrong.", "isError": true };

        // Call this on every return point to make sure global state and DOM gets updated with new state
        let updateDom = () => {
            gActivityList = activityList;
            gActivityErrorMap = activityErrorMap;
            gPortfolioState = portfolioState;
            setImportLogInputMsg(msg.text, msg.isError);
            reloadLogTable();
        };

        const file = event.target.files[0];
        if (!file) {
            msg.text = "No file selected.";
            msg.isError = true;
            return updateDom();
        }

        try {
            activityList = await readJsonFile(file);
            [portfolioState, activityErrorMap] = await processActivityList(activityList);
            if (activityErrorMap.size > 0)
            {
                msg.text = `Problems with uploaded document, ${activityErrorMap.size} errors occurred. See table below.`
                msg.isError = true;
            }
            else
            {
                msg.text = "All good.";
                msg.isError = false;
            }
        } catch (error) {
            console.error(error);
            msg.text = error.message;
            msg.isError = true;
        }

        return updateDom();
    }

    // Reload the activity table view, based on global activity list and error map
    function reloadLogTable() {
        const logTable = document.getElementById("logTable");
        logTable.innerHTML = `
        <thead>
        <tr>
            ${ALL_POSSIBLE_JSON_FIELDS.map(field => `<th>${field}</th>`).join('')}
        </tr>
        </thead>
        <tbody>
        </tbody>
        `;

        for (const [i, item] of gActivityList.entries()) {
            const row = document.createElement("tr");
            row.innerHTML = ALL_POSSIBLE_JSON_FIELDS
                .map(field => `<td>${item[field] === undefined ? '' : item[field]}</td>`)
                .join('');
            logTable.getElementsByTagName("tbody")[0].appendChild(row);

            if (gActivityErrorMap.has(i)) {
                const errorRow = document.createElement("tr");
                errorRow.innerHTML = `
                    <td colspan="${ALL_POSSIBLE_JSON_FIELDS.length}"style="color: red;">
                        Above record contains the following error(s): ${gActivityErrorMap.get(i)}
                    </td>
                `
                logTable.getElementsByTagName("tbody")[0].appendChild(errorRow);
            }
        }
    }

    function onExportLogButtonClick() {
        console.log("onExportLogButtonClick");

        const dataStr = JSON.stringify(gActivityList, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const downloadElement = document.createElement("a");
        downloadElement.href = url;
        downloadElement.download = "portfolio.json";
        document.body.appendChild(downloadElement);
        downloadElement.click();
        document.body.removeChild(downloadElement);
    }

    // FUNCTIONS WITHOUT SIDE EFFECTS

    // Omit "async" as we must explicitly return "Promise" here anyway due to FileReader,
    // which is not promise-based. Function is still await-able.
    function readJsonFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    const parsedData = JSON.parse(e.target.result);
                    resolve(parsedData);
                } catch (error) {
                    reject(error);
                }
            };

            reader.onerror = () => reject(new Error("Failed to read file."));

            reader.readAsText(file);
        });
    }

    /*
     * Process the given activity log JSON, which is expected to be an array of action items.
     * Each item is processed sequentially.
     * Return a tuple of the calculated portfolio state and a map of errors.
     * In the map of errors, the key is the index of the activity item and the value is the error message.
     * If no errors occurred, the map will be empty.
     */
    async function processActivityList(activityFileJson) {
        if (!Array.isArray(activityFileJson)) {
            throw new Error("Top-level JSON must be an array.");
        }

        if (activityFileJson.length === 0) {
            throw new Error("Activity JSON is empty.");
        }

        let portfolioState = {
            platforms: new Map() // Map of platform objects by the platform name
        };
        let activityErrorMap = new Map();

        for (const [i, item] of activityFileJson.entries()) {
            try {
                await processAction(item, portfolioState);
            } catch (error) {
                activityErrorMap.set(i, error.message);
            }
        }

        return [portfolioState, activityErrorMap];
    }

    /*
     * Process a single action item from the activity log, updating the given portfolio state.
     */
    async function processAction(item, portfolioState) {
        if (typeof item !== "object" || item === null) {
            throw new Error(`Item is not a valid JSON object.`);
        }

        for (let key of Object.getOwnPropertyNames(item)) {
            if (!ALL_POSSIBLE_JSON_FIELDS.includes(key)) {
                throw new Error(`Unhandled property: "${key}"`);
            }
        }

        // Validate date existence and format
        let date = undefined;
        try {
            date = await getDateFromStr(item.date);
        } catch (error) {
            throw new Error(`Invalid "date" with value "${item.date}": ${error.message}`);
        }

        // Validate date order
        if (portfolioState.latestDate && date < portfolioState.latestDate) {
            throw new Error(`Date is earlier than the previous action's date.`);
        }
        portfolioState.latestDate = date;

        // Validate action type
        if (!ALL_POSSIBLE_ACTIONS.includes(item.action)) {
            throw new Error(`Unhandled action: "${item.action}"`);
        }

        // Process the action with a dedicated function
        switch (item.action) {
            case "NewPlatform":
                await processActionNewPlatform(item, portfolioState);
                break;
            default:
                throw new Error(`Processing for "${item.action}" is not implemented`);
        }
    }

    /*
     * Validate the "NewPlatform" action of introducing a new investment platform to the portfolio.
     */
    async function processActionNewPlatform(item, portfolioState) {
        // Validate that the platform does not already exist
        if (portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" already exists`);
        }
        // Validate that the platform name is not empty
        if (!item.platform || item.platform.trim() === "") {
            throw new Error(`Platform name cannot be empty`);
        }
        // Validate that the platform name consists of alphanumeric characters
        const platformNameRegex = /^[a-zA-Z0-9]+$/;
        if (!platformNameRegex.test(item.platform)) {
            throw new Error(`Platform name "${item.platform}" must consist of alphanumeric characters only (a-z, A-Z, 0-9)`);
        }
        // Validate that the platform name is not too long
        if (item.platform.length > 50) {
            throw new Error(`Platform name "${item.platform}" is too long, maximum allowed length is 50 characters`);
        }
        // Add the platform to the portfolio
        portfolioState.platforms.set(item.platform, {
            name: item.platform,
            assets: new Map(), // Map of asset objects by the asset code
        });
    }

    // UTILS

    // Validate that the date string in format "DD.MM.YYYY" has correct format and is a valid date.
    // Return a Date object if valid, otherwise throw an error.
    async function getDateFromStr(dateStr) {
        if (!dateStr) {
            throw new Error("String is empty or undefined");
        }

        // Check date format (DD.MM.YYYY)
        const dateRegex = /^(\d{2})\.(\d{2})\.(\d{4})$/;
        const dateMatch = dateStr.match(dateRegex);
        if (!dateMatch) {
            throw new Error(`Expected format DD.MM.YYYY`);
        }

        // Validate that the date is a valid date
        const day = parseInt(dateMatch[1], 10);
        const month = parseInt(dateMatch[2], 10);
        const year = parseInt(dateMatch[3], 10);

        if (day < 1 || day > 31) {
            throw new Error(`Invalid day ${day}`);
        }

        if (month < 1 || month > 12) {
            throw new Error(`Invalid month ${month}`);
        }

        const dateObj = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date

        // Check if the date is valid (e.g., not 31.02.2023)
        if (dateObj.getDate() !== day ||
            dateObj.getMonth() + 1 !== month ||
            dateObj.getFullYear() !== year) {
            throw new Error(`The date does not exist in calendar`);
        }

        console.log(`Successfully parsed date ${dateStr} to ${dateObj.toISOString()}`);
        return dateObj;
    }

</script>

</body>

</html>

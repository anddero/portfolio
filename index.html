<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>

    <!-- CSS Section -->
    <style>
    </style>
</head>

<body>

<!-- Header Section -->
<header>
</header>

<!-- Main Content Section -->
<main>

    <input type="file" id="importLogInput" name="Import">
    <p id="importLogInputMsg"></p>

    <h2>Log</h2>
    <table id="logTable">
    </table>

    <button id="exportLogButton">Export</button>

</main>

<!-- JavaScript Section -->

<script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
<script src="src/utils.js"></script>
<script src="src/portfolio.js"></script>

<script>

    // CONSTANTS

    const ALL_POSSIBLE_JSON_FIELDS = [
        "date",
        "action",
        "platform",
        "assetType",
        "assetCode",
        "totalShares",
        "currency",
        "unitValue",
        "totalValue",
        "feeValue",
        "grossValue",
        "netValue",
        "taxValue",
        "fromPlatform",
        "toPlatform",
        "fromCurrency",
        "fromValue",
        "toCurrency",
        "toValue",
        "fromToCoefficient",
        "friendlyName",
        "notes"
    ];

    const ALL_POSSIBLE_ACTIONS = [
        "Check",
        "NewPlatform",
        "NewAsset",
        "Buy",
        "Deposit",
        "Dividend",
        "CurrencyConversion",
        "PublicToPrivateShareConversion",
        "Other",
        "Transfer",
        "NominalValueReduction",
        "Sell",
        "Interest"
    ];

    const ALL_POSSIBLE_ASSET_TYPES = [
        "Cash",
        "Stock",
        "Bond",
        //"ETF", // Currently not using
        "IndexFund" // Would "MutualFund" be a better name?
    ];

    // STATE

    let gActivityList = []; // Raw activity JSON
    let gActivityErrorMap = new Map(); // Errors in the activity JSON, where key is activity index and value is error message
    let gPortfolioState = {}; // Portfolio structured state such as overview, individual asset summaries, etc

    // EVENT BINDINGS

    document.getElementById('importLogInput').addEventListener('change', onImportLogInputChange);
    document.getElementById('exportLogButton').addEventListener('click', onExportLogButtonClick);

    // EVENT HANDLERS

    function setImportLogInputMsg(message, isError) {
        document.getElementById("importLogInputMsg").innerText = message;
        document.getElementById("importLogInputMsg").style = `color: ${isError ? "red" : "green"};`;
    }

    // Reset all global state, process and validate the given file, set the global state and update DOM
    async function onImportLogInputChange(event) {
        console.log("onImportLogInputChange");

        // New state, initially cleared
        let activityList = [];
        let activityErrorMap = new Map();
        let portfolioState = {};
        let msg = { "text": "Something went wrong.", "isError": true };

        // Call this on every return point to make sure global state and DOM gets updated with new state
        let updateDom = () => {
            gActivityList = activityList;
            gActivityErrorMap = activityErrorMap;
            gPortfolioState = portfolioState;
            setImportLogInputMsg(msg.text, msg.isError);
            reloadLogTable();
        };

        const file = event.target.files[0];
        if (!file) {
            msg.text = "No file selected.";
            msg.isError = true;
            return updateDom();
        }

        try {
            activityList = await readJsonFile(file); // await very much needed here as readJsonFile cannot be made sync function
            let criticalErrorOccurred;
            [portfolioState, activityErrorMap, criticalErrorOccurred] = processActivityList(activityList);
            if (activityErrorMap.size > 0)
            {
                if (criticalErrorOccurred) {
                    msg.text = `You have ${activityErrorMap.size} issue(s), where the last detected issue is a critical error. The log processing is incomplete and calculated data partial! See table below for the line where the issue occurred. Please fix the issue and reload the log.`;
                } else {
                    msg.text = `You have ${activityErrorMap.size} warning(s). See table below for the lines where they occurred. The entire log has been processed and it is safe to continue if you choose to ignore the warnings.`
                }
                msg.isError = true;
            }
            else
            {
                msg.text = "All good.";
                msg.isError = false;
            }
        } catch (error) {
            console.error(error);
            msg.text = `Critical error, no data has been processed. Please fix the issue and reload the log. Error: ${error.message}`;
            msg.isError = true;
        }

        return updateDom();
    }

    // Reload the activity table view, based on global activity list and error map
    function reloadLogTable() {
        const logTable = document.getElementById("logTable");
        logTable.innerHTML = `
        <thead>
        <tr>
            ${ALL_POSSIBLE_JSON_FIELDS.map(field => `<th>${field}</th>`).join('')}
        </tr>
        </thead>
        <tbody>
        </tbody>
        `;

        for (const [i, item] of gActivityList.entries()) {
            const row = document.createElement("tr");
            row.innerHTML = ALL_POSSIBLE_JSON_FIELDS
                .map(field => `<td>${item[field] === undefined ? '' : item[field]}</td>`)
                .join('');
            logTable.getElementsByTagName("tbody")[0].appendChild(row);

            if (gActivityErrorMap.has(i)) {
                const errorRow = document.createElement("tr");
                errorRow.innerHTML = `
                    <td colspan="${ALL_POSSIBLE_JSON_FIELDS.length}"style="color: red;">
                        Applies to the above record: ${gActivityErrorMap.get(i)}
                    </td>
                `
                logTable.getElementsByTagName("tbody")[0].appendChild(errorRow);
            }
        }
    }

    function onExportLogButtonClick() {
        console.log("onExportLogButtonClick");

        const dataStr = JSON.stringify(gActivityList, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const downloadElement = document.createElement("a");
        downloadElement.href = url;
        downloadElement.download = "portfolio.json";
        document.body.appendChild(downloadElement);
        downloadElement.click();
        document.body.removeChild(downloadElement);
    }

    // FUNCTIONS WITHOUT SIDE EFFECTS

    // Omit "async" as we must explicitly return "Promise" here anyway due to FileReader,
    // which is not promise-based. Function is still await-able.
    function readJsonFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    resolve(JSON.parse(e.target.result));
                } catch (error) {
                    reject(error);
                }
            };

            reader.onerror = () => reject(new Error("Failed to read file."));

            reader.readAsText(file);
        });
    }

    /*
     * Process the given activity log JSON, which is expected to be an array of action items.
     * Each item is processed sequentially.
     * Return a tuple of [calculated portfolio state; map of errors/warnings; whether an error has occurred].
     *
     * In the returned map of errors, the key is the index of the activity item and the value is the error message.
     * If no errors occurred, the map will be empty.
     * If an error has occurred, the processing stops and the calculated portfolio state will be partial.
     * If an error has not occurred, the map will only contain warnings (if any). All data will be successfully processed.
     *
     * Throw in case of a critical error which isn't tied to a specific activity item.
     */
    function processActivityList(activityFileJson) {
        if (!Array.isArray(activityFileJson)) {
            throw new Error("Top-level JSON must be an array.");
        }

        if (activityFileJson.length === 0) {
            throw new Error("Activity JSON is empty.");
        }

        let portfolioState = {
            platforms: new Map() // Map of platform objects by the platform name
        };
        let activityErrorMap = new Map();

        let criticalErrorOccurred = false;
        for (const [i, item] of activityFileJson.entries()) {
            try {
                let warnings = processAction(item, portfolioState);
                if (warnings.length > 0) {
                    activityErrorMap.set(i, `You have ${warnings.length} warning(s): ${warnings.join(' ')}`);
                }
            } catch (error) {
                activityErrorMap.set(i, `Critical error occurred, further processing stopped: ${error.message}`);
                criticalErrorOccurred = true;
                break;
            }
        }

        return [portfolioState, activityErrorMap, criticalErrorOccurred];
    }

    /*
     * Process a single action item from the activity log, updating the given portfolio state.
     * Return a list of warnings (maybe empty).
     * Throw in case of a critical error in which case the activity item may not be correctly processed.
     */
    function processAction(item, portfolioState) {
        if (typeof item !== "object" || item === null) {
            throw new Error(`Item is not a valid JSON object.`);
        }

        for (let key of Object.getOwnPropertyNames(item)) {
            if (!ALL_POSSIBLE_JSON_FIELDS.includes(key)) {
                throw new Error(`Unhandled property: "${key}"`);
            }
        }

        // Validate date existence and format
        let date = undefined;
        try {
            date = getDateFromStr(item.date);
        } catch (error) {
            throw new Error(`Invalid "date" with value "${item.date}": ${error.message}`);
        }

        // Validate date order
        if (portfolioState.latestDate && date < portfolioState.latestDate) {
            throw new Error(`Date is earlier than the previous action's date.`);
        }
        portfolioState.latestDate = date;

        // Validate action type
        if (!ALL_POSSIBLE_ACTIONS.includes(item.action)) {
            throw new Error(`Unhandled action: "${item.action}"`);
        }

        // Process the action with a dedicated function
        switch (item.action) {
            case "NewPlatform":
                return processActionNewPlatform(item, portfolioState);
            case "NewAsset":
                return processActionNewAsset(item, portfolioState);
            case "Check":
                return processActionCheck(item, portfolioState);
            case "Deposit":
                return processActionDeposit(item, portfolioState);
            case "Buy":
                return processActionBuy(item, portfolioState);
            case "Sell":
                return processActionSell(item, portfolioState);
            case "Dividend":
                return processActionDividend(item, portfolioState);
            case "CurrencyConversion":
                return processActionCurrencyConversion(item, portfolioState);
            case "Transfer":
                return processActionTransfer(item, portfolioState);
            case "NominalValueReduction":
                return processActionNominalValueReduction(item, portfolioState);
            case "PublicToPrivateShareConversion":
                return processActionPublicToPrivateShareConversion(item, portfolioState);
            default:
                throw new Error(`Processing for "${item.action}" is not implemented`);
        }
    }

    function processActionPublicToPrivateShareConversion(item, portfolioState) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is supported
        if (item.assetType !== "Stock") {
            throw new Error(`Asset type "${item.assetType}" is not supported for "NominalValueReduction" action`);
        }
        // Validate the asset code
        validateInputAssetCode(item.assetCode);
        // Validate that the asset code exists on the platform
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.stock.has(item.assetCode)) {
            throw new Error(`Asset code "${item.assetCode}" does not exist on platform "${item.platform}"`);
        }
        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate that the currency matches the existing asset currency
        const existingCurrency = platform.stock.get(item.assetCode).getCurrency();
        if (existingCurrency !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${existingCurrency}"`);
        }
        // Validate the fee value
        const feeValueDecimal = parseAmountToDecimal(item.feeValue, "feeValue", 2);
        // Validate that the fee value is positive
        if (feeValueDecimal.lessThanOrEqualTo(0)) {
            warnings.push(`Fee value "${item.feeValue}" is not a positive amount.`);
        }
        // Subtract the fee value from the platform
        warnings = warnings.concat(updateCash(platform, item.currency, feeValueDecimal.negated()));

        return warnings;
    }

    function processActionNominalValueReduction(item, portfolioState) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is supported
        if (item.assetType !== "Stock") {
            throw new Error(`Asset type "${item.assetType}" is not supported for "NominalValueReduction" action`);
        }
        // Validate the asset code
        validateInputAssetCode(item.assetCode);
        // Validate that the asset code exists on the platform
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.stock.has(item.assetCode)) {
            throw new Error(`Asset code "${item.assetCode}" does not exist on platform "${item.platform}"`);
        }
        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate that the currency matches the existing asset currency
        const existingCurrency = platform.stock.get(item.assetCode).getCurrency();
        if (existingCurrency !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${existingCurrency}"`);
        }
        // Validate the total value
        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);
        // Validate that the total value is positive
        if (totalValueDecimal.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Add the received cash to the platform
        warnings = warnings.concat(updateCash(platform, item.currency, totalValueDecimal));

        return warnings;
    }

    function processActionTransfer(item, portfolioState) {
        let warnings = [];

        // Validate the from platform existence
        if (!portfolioState.platforms.has(item.fromPlatform)) {
            throw new Error(`From platform "${item.fromPlatform}" does not exist`);
        }
        // Validate the to platform existence
        if (!portfolioState.platforms.has(item.toPlatform)) {
            throw new Error(`To platform "${item.toPlatform}" does not exist`);
        }
        // Validate the asset type
        if (item.assetType !== "Cash") {
            throw new Error(`Asset type "${item.assetType}" is not supported for "Transfer" action`);
        }
        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate the value
        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);
        // Validate that the transferred amount is positive
        if (totalValueDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`Total value "${item.totalValue}" is not a positive amount`);
        }
        // Validate the fee value
        const feeValueDecimal = parseAmountToDecimal(item.feeValue, "feeValue", 2);
        // Validate that the fee value is non-negative
        if (feeValueDecimal.lessThan(0)) {
            throw new Error(`Fee value "${item.feeValue}" is not a non-negative amount`);
        }
        // Update the cash amount on the from platform
        const fromPlatform = portfolioState.platforms.get(item.fromPlatform);
        warnings = warnings.concat(updateCash(fromPlatform, item.currency, totalValueDecimal.negated().plus(feeValueDecimal)));
        // Update the cash amount on the to platform
        const toPlatform = portfolioState.platforms.get(item.toPlatform);
        warnings = warnings.concat(updateCash(toPlatform, item.currency, totalValueDecimal));
        return warnings;
    }

    function processActionCurrencyConversion(item, portfolioState) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is Cash
        if (item.assetType !== "Cash") {
            throw new Error(`Asset type "${item.assetType}" is not supported for "CurrencyConversion" action`);
        }
        // Validate the from currency
        validateInputCurrency(item.fromCurrency);
        // Validate the to currency
        validateInputCurrency(item.toCurrency);
        // Validate the from value
        const fromValueDecimal = parseAmountToDecimal(item.fromValue, "fromValue", 2);
        // Validate that the from value is positive
        if (fromValueDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`From value "${item.fromValue}" is not a positive amount`);
        }
        // Validate the to value
        const toValueDecimal = parseAmountToDecimal(item.toValue, "toValue", 2);
        // Validate that the to value is positive
        if (toValueDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`To value "${item.toValue}" is not a positive amount`);
        }
        // Validate the from-to coefficient
        const fromToCoefficientDecimal = new Decimal(item.fromToCoefficient);
        if (fromToCoefficientDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`From-to coefficient "${item.fromToCoefficient}" must be a positive number`);
        }
        // Check that the conversion makes sense
        const expectedToValue = fromValueDecimal.times(fromToCoefficientDecimal);
        if (!toValueDecimal.equals(expectedToValue)) {
            warnings.push(`To value ${toValueDecimal} does not match the product of from value ${fromValueDecimal} and from-to coefficient ${fromToCoefficientDecimal}, expected ${expectedToValue}.`);
        }

        // Update the cash amounts on the platform
        const platform = portfolioState.platforms.get(item.platform);

        warnings = warnings.concat(updateCash(platform, item.fromCurrency, fromValueDecimal.negated()));
        warnings = warnings.concat(updateCash(platform, item.toCurrency, toValueDecimal));
        return warnings;
    }

    function processActionDividend(item, portfolioState) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is supported
        if (item.assetType !== "Stock") {
            throw new Error(`Asset type "${item.assetType}" is not supported for "Dividend" action`);
        }
        // Validate the asset code
        validateInputAssetCode(item.assetCode);
        // Validate that the asset code exists on the platform
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.stock.has(item.assetCode)) {
            throw new Error(`Asset code "${item.assetCode}" does not exist on platform "${item.platform}"`);
        }
        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate that the currency matches the existing asset currency
        const existingCurrency = platform.stock.get(item.assetCode).getCurrency();
        if (existingCurrency !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${existingCurrency}"`);
        }
        // Validate the gross value
        const grossValueDecimal = parseAmountToDecimal(item.grossValue, "grossValue", 2);
        // Validate that the gross value is positive
        if (grossValueDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`Gross value "${item.grossValue}" is not a positive amount`);
        }
        // Validate the net value
        const netValueDecimal = parseAmountToDecimal(item.netValue, "netValue", 2);
        // Validate that the net value is positive
        if (netValueDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`Net value "${item.netValue}" is not a positive amount`);
        }
        // Validate the tax value
        const taxValueDecimal = parseAmountToDecimal(item.taxValue, "taxValue", 2);
        // Validate that the tax value is positive
        if (taxValueDecimal.lessThan(0)) {
            throw new Error(`Tax value "${item.taxValue}" is not a non-negative amount`);
        }
        // Validate that the net value is less than or equal to the gross value
        if (netValueDecimal.greaterThan(grossValueDecimal)) {
            throw new Error(`Net value "${item.netValue}" cannot be greater than gross value "${item.grossValue}"`);
        }
        // Validate that the tax value is less than or equal to the gross value
        if (taxValueDecimal.greaterThan(grossValueDecimal)) {
            throw new Error(`Tax value "${item.taxValue}" cannot be greater than gross value "${item.grossValue}"`);
        }
        // Validate that the net value plus tax value equals gross value
        const expectedGrossValueDecimal = netValueDecimal.plus(taxValueDecimal);
        if (!grossValueDecimal.equals(expectedGrossValueDecimal)) {
            throw new Error(`Gross value ${grossValueDecimal} does not match the sum of net value and tax value, expected ${expectedGrossValueDecimal}`);
        }

        // Update the cash amount on the platform
        warnings = warnings.concat(updateCash(platform, item.currency, netValueDecimal));
        return warnings;
    }

    /*
     * Process the "Buy" action of purchasing an asset on a platform.
     */
    function processActionBuy(item, portfolioState) {
        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is supported
        if (!ALL_POSSIBLE_ASSET_TYPES.includes(item.assetType)) {
            throw new Error(`Asset type "${item.assetType}" is not supported`);
        }
        // Process the asset with a dedicated function
        switch (item.assetType) {
            case "Stock":
                return processActionBuyStock(item, portfolioState);
            case "IndexFund":
                return processActionBuyIndexFund(item, portfolioState);
            default:
                throw new Error(`Processing of "Buy" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "Sell" action of purchasing an asset on a platform.
     */
    function processActionSell(item, portfolioState) {
        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is supported
        if (!ALL_POSSIBLE_ASSET_TYPES.includes(item.assetType)) {
            throw new Error(`Asset type "${item.assetType}" is not supported`);
        }
        // Process the asset with a dedicated function
        switch (item.assetType) {
            // case "Stock":
            //     return processActionBuyStock(item, portfolioState);
            case "IndexFund":
                return processActionSellIndexFund(item, portfolioState);
            default:
                throw new Error(`Processing of "Sell" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "Buy" action for asset type "Stock" of purchasing stock.
     */
    function processActionBuyStock(item, portfolioState) {
        let warnings = [];

        validateInputAssetCode(item.assetCode);
        // Validate that the asset code exists on the platform
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.stock.has(item.assetCode)) {
            throw new Error(`Stock with code "${item.assetCode}" does not exist on platform "${item.platform}"`);
        }
        const shareCount = parseAmountToDecimal(item.totalShares, "totalShares", 2);
        // Validate that the share count is positive
        if (shareCount.lessThan(0)) {
            throw new Error(`Share count "${item.totalShares}" is not a positive number`);
        }
        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate that the currency matches the existing asset currency
        const existingCurrency = platform.stock.get(item.assetCode).getCurrency();
        if (existingCurrency !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${existingCurrency}"`);
        }
        // Validate the unit value
        const unitValueDecimal = parseAmountToDecimal(item.unitValue, "unitValue", 8);
        // Validate that the unit value is positive
        if (unitValueDecimal.lessThanOrEqualTo(0)) {
            warnings.push(`Unit value "${item.unitValue}" is not a positive amount.`);
        }
        // Validate the total value
        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);
        // Validate that the total value is positive
        if (totalValueDecimal.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Validate the total value against unit value and share count
        const expectedTotalValueDecimal = unitValueDecimal.times(shareCount);
        if (!totalValueDecimal.equals(expectedTotalValueDecimal)) {
            warnings.push(`Total value ${totalValueDecimal} does not match the product of share count and unit value, expected ${expectedTotalValueDecimal}.`);
        }
        // Subtract the spent cash from the platform
        warnings = warnings.concat(updateCash(platform, item.currency, totalValueDecimal.negated()));
        // Add the shares to the platform
        warnings = warnings.concat(updateStock(platform, item.assetCode, shareCount));

        return warnings;
    }

    /*
     * Process the "Buy" action for asset type "IndexFund" of purchasing index fund.
     */
    function processActionBuyIndexFund(item, portfolioState) {
        let warnings = [];

        validateInputAssetCode(item.assetCode);
        // Validate that the asset code exists on the platform
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.indexFund.has(item.assetCode)) {
            throw new Error(`Index fund with code "${item.assetCode}" does not exist on platform "${item.platform}"`);
        }

        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate that the currency matches the existing asset currency
        const existingCurrency = platform.indexFund.get(item.assetCode).getCurrency();
        if (existingCurrency !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${existingCurrency}"`);
        }
        // Validate the total value
        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);
        // Validate that the total value is positive
        if (totalValueDecimal.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Subtract the spent cash from the platform
        warnings = warnings.concat(updateCash(platform, item.currency, totalValueDecimal.negated()));
        // Add the index fund cash to the platform
        warnings = warnings.concat(updateIndexFund(platform, item.assetCode, totalValueDecimal));
        return warnings;
    }

    /*
     * Process the "Sell" action for asset type "IndexFund".
     */
    function processActionSellIndexFund(item, portfolioState) {
        let warnings = [];

        validateInputAssetCode(item.assetCode);

        // Validate that the asset code exists on the platform
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.indexFund.has(item.assetCode)) {
            throw new Error(`Asset code "${item.assetCode}" does not exist on platform "${item.platform}"`);
        }

        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate that the currency matches the existing asset currency
        const existingCurrency = platform.indexFund.get(item.assetCode).getCurrency();
        if (existingCurrency !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${existingCurrency}"`);
        }
        // Validate the total value
        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);
        // Validate that the total value is positive
        if (totalValueDecimal.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Add the acquired cash to the platform
        warnings = warnings.concat(updateCash(platform, item.currency, totalValueDecimal));
        // Subtract the index fund cash from the platform
        warnings = warnings.concat(updateIndexFund(platform, item.assetCode, totalValueDecimal.negated()));
        return warnings;
    }

    /*
     * Process the "Deposit" action of adding cash to a platform.
     */
    function processActionDeposit(item, portfolioState) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset is cash
        if (item.assetType !== "Cash") {
            throw new Error(`Asset type "${item.assetType}" is not supported for "Deposit" action`);
        }
        // Validate the currency
        validateInputCurrency(item.currency);
        // Validate the value
        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);
        // Validate that the deposited amount is positive
        if (totalValueDecimal.lessThanOrEqualTo(0)) {
            throw new Error(`Total value "${item.totalValue}" is not a positive amount`);
        }
        // Update the cash amount on the platform
        const platform = portfolioState.platforms.get(item.platform);
        warnings = warnings.concat(updateCash(platform, item.currency, totalValueDecimal));
        return warnings;
    }

    /*
     * Process the "Check" action of validating an asset's current value.
     */
    function processActionCheck(item, portfolioState) {
        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate the asset type
        if (!ALL_POSSIBLE_ASSET_TYPES.includes(item.assetType)) {
            throw new Error(`Asset type "${item.assetType}" is not supported`);
        }
        // Process the asset with a dedicated function
        switch (item.assetType) {
            case "Cash":
                return processActionCheckCash(item, portfolioState);
            default:
                throw new Error(`Processing of "Check" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "Check" action for asset type "Cash" of validating the current cash amount.
     */
    function processActionCheckCash(item, portfolioState) {
        let warnings = [];

        validateInputCurrency(item.currency);

        const totalValueDecimal = parseAmountToDecimal(item.totalValue, "totalValue", 2);

        // Check that the cash exists on the platform.
        const platform = portfolioState.platforms.get(item.platform);
        if (!platform.cash.has(item.currency)) {
            throw new Error(`Cash "${item.currency}" does not exist on platform`);
        }

        // Get the cash amount from the platform.
        const cashAmountDecimal = platform.cash.get(item.currency).getCurrentValue();

        // Validate the amount
        if (!cashAmountDecimal.equals(totalValueDecimal)) {
            warnings.push(`Current cash amount for currency "${item.currency}" is ${cashAmountDecimal} but expected ${item.totalValue}`);
        }

        return warnings;
    }

    /*
     * Process the "NewPlatform" action of introducing a new investment platform to the portfolio.
     */
    function processActionNewPlatform(item, portfolioState) {
        let warnings = [];

        // Validate that the platform does not already exist
        if (portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" already exists`);
        }
        // Validate that the platform name is not empty
        if (!item.platform || item.platform.trim() === "") {
            throw new Error(`Platform name cannot be empty`);
        }
        // Validate that the platform name consists of alphanumeric characters
        const platformNameRegex = /^[a-zA-Z0-9]+$/;
        if (!platformNameRegex.test(item.platform)) {
            throw new Error(`Platform name "${item.platform}" must consist of alphanumeric characters only (a-z, A-Z, 0-9)`);
        }
        // Validate that the platform name is not too long
        if (item.platform.length > 50) {
            throw new Error(`Platform name "${item.platform}" is too long, maximum allowed length is 50 characters`);
        }
        // Add the platform to the portfolio
        portfolioState.platforms.set(item.platform, {
            name: item.platform,
            cash: new Map(), // Map of CashHolding objects by the currency code
            stock: new Map(), // Map of StockHolding objects by the asset code
            indexFund: new Map(), // Map of IndexFundHolding objects by the asset code
        });

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset to the portfolio.
     */
    function processActionNewAsset(item, portfolioState) {
        // Validate that the platform exists
        if (!portfolioState.platforms.has(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the asset type is supported
        if (!ALL_POSSIBLE_ASSET_TYPES.includes(item.assetType)) {
            throw new Error(`Asset type "${item.assetType}" is not supported`);
        }
        // Different function per asset type
        switch (item.assetType) {
            case "Stock":
                return processActionNewAssetStock(item, portfolioState);
            case "IndexFund":
                return processActionNewAssetIndexFund(item, portfolioState);
            case "Cash":
                return processActionNewAssetCash(item, portfolioState);
            default:
                throw new Error(`Processing of "NewAsset" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "Stock" to the portfolio.
     */
    function processActionNewAssetStock(item, portfolioState) {
        let warnings = [];

        // Validate the asset code
        validateInputAssetCode(item.assetCode);
        // Validate that the asset code does not already exist on the platform
        const platform = portfolioState.platforms.get(item.platform);
        // TODO Check across all asset types and names for uniqueness.
        // Validate the asset currency
        validateInputCurrency(item.currency);
        // Validate the friendly asset name
        validateInputAssetFriendlyName(item.friendlyName);
        // Validate that the friendly name does not already exist on the platform
        // TODO Check across all asset types and names for uniqueness.
        // Add the new stock holding to the platform
        platform.stock.set(item.assetCode, new StockHolding(item.assetCode, item.friendlyName, item.currency));

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "IndexFund" to the portfolio.
     */
    function processActionNewAssetIndexFund(item, portfolioState) {
        let warnings = [];

        // Validate the asset code
        validateInputAssetCode(item.assetCode);
        // Validate that the asset code does not already exist on the platform
        const platform = portfolioState.platforms.get(item.platform);
        // TODO Check across all asset types and names for uniqueness.
        // Validate the asset currency
        validateInputCurrency(item.currency);
        // Validate the friendly asset name
        validateInputAssetFriendlyName(item.friendlyName);
        // Validate that the friendly name does not already exist on the platform
        // TODO Check across all asset types and names for uniqueness.
        // Add the new stock holding to the platform
        platform.indexFund.set(item.assetCode, new IndexFundHolding(item.assetCode, item.friendlyName, item.currency));

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "Cash" to the portfolio.
     */
    function processActionNewAssetCash(item, portfolioState) {
        let warnings = [];

        // Validate the asset currency
        validateInputCurrency(item.currency);

        // Validate that the currency does not already exist on the platform.
        const platform = portfolioState.platforms.get(item.platform);
        if (platform.cash.has(item.currency)) {
            throw new Error(`Cash "${item.currency}" already exists on platform "${item.platform}"`);
        }
        // Add the new cash holding to the platform.
        platform.cash.set(item.currency, new CashHolding(item.currency));

        return warnings;
    }

    function updateCash(platform, currency, updateDecimal) {
        let warnings = [];
        // Check that the currency exists on the platform.
        if (!platform.cash.has(currency)) {
            throw new Error(`Cash "${currency}" does not exist on platform "${platform.name}"`);
        }
        // Update the amount.
        let newAmt = platform.cash.get(currency).updateValue(updateDecimal);
        if (newAmt.lessThan(0)) {
            warnings.push(`Platform "${platform.name}" has become negative in currency "${currency}", new amount is ${newAmt}.`);
        }
        return warnings;
    }

    function updateIndexFund(platform, assetCode, updateDecimal) {
        let warnings = [];
        // Check that the index fund exists on the platform.
        if (!platform.indexFund.has(assetCode)) {
            throw new Error(`Index fund "${assetCode}" does not exist on platform "${platform.name}"`);
        }
        // Update the amount.
        let newAmt = platform.indexFund.get(assetCode).updateShares(updateDecimal);
        if (newAmt.lessThan(0)) {
            warnings.push(`Platform "${platform.name}" has become negative in index fund "${assetCode}", current amount is ${newAmt}.`);
        }
        return warnings;
    }

    function updateStock(platform, assetCode, shareCountDecimal) {
        let warnings = [];
        if (!platform.stock.has(assetCode)) {
            throw new Error(`Stock "${assetCode}" does not exist on platform "${platform.name}"`);
        }
        let newShares = platform.stock.get(assetCode).updateShares(shareCountDecimal);
        if (newShares.lessThan(0)) {
            warnings.push(`Platform "${platform.name}" has become negative in stock "${assetCode}", new shares ${newShares}.`);
        }
        return warnings;
    }

    // UTILS

    /*
     * Parse a decimal amount string to a Decimal object.
     * The string should be in format "1234.56", "-0.09", "0,00", "1,2", "49", etc.
     */
    function parseAmountToDecimal(amountStr, fieldName, maxDecimals) {
        validateIntInRange(maxDecimals, 2, 10).orThrow('maxDecimals');
        // Validate that the value is given
        if (amountStr === undefined || amountStr === null || typeof amountStr !== "string" || amountStr === "") {
            throw new Error(`Field "${fieldName}" missing or empty`);
        }
        // Validate that the value is a valid decimal amount string
        const decimalAmountRegex = new RegExp(`^-?\\d+([.,]\\d{1,${maxDecimals}})?$`);
        if (!decimalAmountRegex.test(amountStr)) {
            throw new Error(`Field "${fieldName}" value "${amountStr}" invalid, expected a decimal amount`);
        }
        // Convert the string to a Decimal object
        return new Decimal(amountStr.replace(',', '.')); // Normalize comma to dot
    }

    function validateInputAssetCode(assetCode) {
        // Validate that the asset code is given
        if (!assetCode || typeof assetCode !== "string" || assetCode.trim() === "") {
            throw new Error(`Missing asset code or invalid type`);
        }
        // Validate that the asset code is not too long
        if (assetCode.length > 50) {
            throw new Error(`Asset code is too long, maximum allowed length is 50 characters`);
        }
        // Validate the asset code format
        const assetCodeRegex = /^[a-zA-Z0-9]+$/;
        if (!assetCodeRegex.test(assetCode)) {
            throw new Error(`Asset code "${assetCode}" must consist of alphanumeric characters only (a-z, A-Z, 0-9)`);
        }
    }

    function validateInputAssetFriendlyName(assetName) {
        // Validate that the asset name is given
        if (!assetName || typeof assetName !== "string" || assetName.trim() === "") {
            throw new Error(`Missing asset name or invalid type`);
        }
        // Validate that the asset name is not too long
        if (assetName.length > 50) {
            throw new Error(`Asset name is too long, maximum allowed length is 50 characters`);
        }
        // Validate the asset name format
        const assetNameRegex = /^[a-zA-Z0-9 ]+$/;
        if (!assetNameRegex.test(assetName)) {
            throw new Error(`Asset name "${assetName}" must consist of alphanumeric characters (a-z, A-Z, 0-9) and spaces only`);
        }
    }

    function validateInputCurrency(currency) {
        // Validate the currency code
        if (!currency || currency.trim() === "") {
            throw new Error(`Currency code cannot be empty`);
        }
        // Validate that the currency code consists of alphanumeric characters
        const currencyCodeRegex = /^[a-zA-Z0-9]+$/;
        if (!currencyCodeRegex.test(currency)) {
            throw new Error(`Currency code "${currency}" must consist of alphanumeric characters only (a-z, A-Z, 0-9)`);
        }
        // Validate that the currency code is not too long
        if (currency.length > 50) {
            throw new Error(`Currency code "${currency}" is too long, maximum allowed length is 50 characters`);
        }
    }

    // Validate that the date string in format "DD.MM.YYYY" has correct format and is a valid date.
    // Return a Date object if valid, otherwise throw an error.
    function getDateFromStr(dateStr) {
        if (!dateStr) {
            throw new Error("String is empty or undefined");
        }

        // Check date format (DD.MM.YYYY)
        const dateRegex = /^(\d{2})\.(\d{2})\.(\d{4})$/;
        const dateMatch = dateStr.match(dateRegex);
        if (!dateMatch) {
            throw new Error(`Expected format DD.MM.YYYY`);
        }

        // Validate that the date is a valid date
        const day = parseInt(dateMatch[1], 10);
        const month = parseInt(dateMatch[2], 10);
        const year = parseInt(dateMatch[3], 10);

        if (day < 1 || day > 31) {
            throw new Error(`Invalid day ${day}`);
        }

        if (month < 1 || month > 12) {
            throw new Error(`Invalid month ${month}`);
        }

        const dateObj = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript Date

        // Check if the date is valid (e.g., not 31.02.2023)
        if (dateObj.getDate() !== day ||
            dateObj.getMonth() + 1 !== month ||
            dateObj.getFullYear() !== year) {
            throw new Error(`The date does not exist in calendar`);
        }

        console.log(`Successfully parsed date ${dateStr} to ${dateObj.toISOString()}`);
        return dateObj;
    }

</script>

</body>

</html>

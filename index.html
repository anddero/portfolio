<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>

    <!-- CSS Section -->
    <style>
    </style>
</head>

<body>

<!-- Header Section -->
<header>
</header>

<!-- Main Content Section -->
<main>

    <input type="file" id="importLogInput" name="Import">
    <p id="importLogInputMsg"></p>

    <h2>Log</h2>
    <table id="summaryTable">
    </table>
    <table id="logTable">
    </table>

    <button id="exportLogButton">Export</button>

</main>

<!-- JavaScript Section -->

<script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
<script src="src/utils.js"></script>
<script src="src/portfolio.js"></script>

<script>

    // CONSTANTS

    const ALL_POSSIBLE_JSON_FIELDS = [
        "date",
        "action",
        "platform",
        "assetType",
        "assetCode",
        "totalShares",
        "currency",
        "unitValue",
        "totalValue",
        "feeValue",
        "grossValue",
        "netValue",
        "taxValue",
        "fromPlatform",
        "toPlatform",
        "fromCurrency",
        "fromValue",
        "toCurrency",
        "toValue",
        "fromToCoefficient",
        "friendlyName",
        "notes"
    ];

    // Boolean tells whether the action requires an asset type to be specified.
    const ACTIONS = {
        "Check": true,
        "NewPlatform": false,
        "NewAsset": true,
        "Buy": true,
        "Deposit": true,
        "Dividend": true,
        "CurrencyConversion": true,
        "PublicToPrivateShareConversion": true,
        // "Other": true,
        "Transfer": true,
        "UnspecificAccountingIncomeAction": true,
        "Sell": true,
        "Interest": true
    };

    const ASSET_TYPES = [
        "Cash",
        "Stock",
        "Bond",
        "IndexFund" // TODO Would "MutualFund" be a better name?
    ];

    // STATE

    let gActivityList = []; // Raw activity JSON
    let gActivityErrorMap = new Map(); // Errors in the activity JSON, where key is activity index and value is error message
    let gPortfolioState = {}; // Portfolio structured state such as overview, individual asset summaries, etc

    // EVENT BINDINGS

    document.getElementById('importLogInput').addEventListener('change', onImportLogInputChange);
    document.getElementById('exportLogButton').addEventListener('click', onExportLogButtonClick);

    // EVENT HANDLERS

    function setImportLogInputMsg(message, isError) {
        document.getElementById("importLogInputMsg").innerText = message;
        document.getElementById("importLogInputMsg").style = `color: ${isError ? "red" : "green"};`;
    }

    // Reset all global state, process and validate the given file, set the global state and update DOM
    async function onImportLogInputChange(event) {
        console.log("onImportLogInputChange");

        // New state, initially cleared
        let activityList = [];
        let activityErrorMap = new Map();
        let portfolioObj = undefined;
        let msg = { "text": "Something went wrong.", "isError": true };

        // Call this on every return point to make sure global state and DOM gets updated with new state
        let updateDom = () => {
            gActivityList = activityList;
            gActivityErrorMap = activityErrorMap;
            gPortfolioState = portfolioObj;
            setImportLogInputMsg(msg.text, msg.isError);
            reloadLogTable();
            reloadSummaryTable();
        };

        const file = event.target.files[0];
        if (!file) {
            msg.text = "No file selected.";
            msg.isError = true;
            return updateDom();
        }

        try {
            activityList = await readJsonFile(file); // await very much needed here as readJsonFile cannot be made sync function
            let criticalErrorOccurred;
            [portfolioObj, activityErrorMap, criticalErrorOccurred] = processActivityList(activityList);
            if (activityErrorMap.size > 0)
            {
                if (criticalErrorOccurred) {
                    msg.text = `You have ${activityErrorMap.size} issue(s), where the last detected issue is a critical error. The log processing is incomplete and calculated data partial! See table below for the line where the issue occurred. Please fix the issue and reload the log.`;
                } else {
                    msg.text = `You have ${activityErrorMap.size} warning(s). See table below for the lines where they occurred. The entire log has been processed and it is safe to continue if you choose to ignore the warnings.`
                }
                msg.isError = true;
            }
            else
            {
                msg.text = "All good.";
                msg.isError = false;
            }
        } catch (error) {
            console.error(error);
            msg.text = `Critical error, no data has been processed. Please fix the issue and reload the log. Error: ${error.message}`;
            msg.isError = true;
        }

        return updateDom();
    }

    // Reload the summary table view, based on global portfolio object
    function reloadSummaryTable() {
        const summaryTable = document.getElementById("summaryTable");
        summaryTable.innerHTML = `
        <thead>
        <tr>
            <th>Index</th>
            <th>Platform</th>
            <th>Type</th>
            <th>Name</th>
            <th>Count</th>
            <th>Currency</th>
            <th>Code</th>
        </tr>
        </thead>
        <tbody>
        </tbody>
        `;

        for (const [i, item] of gPortfolioState.getSummary().entries()) {
            const row = document.createElement("tr");
            row.innerHTML = `
                <td>${i}</td>
                <td>${item.platformName}</td>
                <td>${item.assetType}</td>
                <td>${item.assetFriendlyName}</td>
                <td>${item.count}</td>
                <td>${item.currency}</td>
                <td>${item.assetCode}</td>
            `;
            summaryTable.getElementsByTagName("tbody")[0].appendChild(row);
        }
    }

    // Reload the activity table view, based on global activity list and error map
    function reloadLogTable() {
        const logTable = document.getElementById("logTable");
        logTable.innerHTML = `
        <thead>
        <tr>
            ${ALL_POSSIBLE_JSON_FIELDS.map(field => `<th>${field}</th>`).join('')}
        </tr>
        </thead>
        <tbody>
        </tbody>
        `;

        for (const [i, item] of gActivityList.entries()) {
            const row = document.createElement("tr");
            row.innerHTML = ALL_POSSIBLE_JSON_FIELDS
                .map(field => `<td>${item[field] === undefined ? '' : item[field]}</td>`)
                .join('');
            logTable.getElementsByTagName("tbody")[0].appendChild(row);

            if (gActivityErrorMap.has(i)) {
                const errorRow = document.createElement("tr");
                errorRow.innerHTML = `
                    <td colspan="${ALL_POSSIBLE_JSON_FIELDS.length}"style="color: red;">
                        Applies to the above record: ${gActivityErrorMap.get(i)}
                    </td>
                `
                logTable.getElementsByTagName("tbody")[0].appendChild(errorRow);
            }
        }
    }

    function onExportLogButtonClick() {
        console.log("onExportLogButtonClick");

        const dataStr = JSON.stringify(gActivityList, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const downloadElement = document.createElement("a");
        downloadElement.href = url;
        downloadElement.download = "portfolio.json";
        document.body.appendChild(downloadElement);
        downloadElement.click();
        document.body.removeChild(downloadElement);
    }

    // FUNCTIONS WITHOUT SIDE EFFECTS

    // Omit "async" as we must explicitly return "Promise" here anyway due to FileReader,
    // which is not promise-based. Function is still await-able.
    function readJsonFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    resolve(JSON.parse(e.target.result));
                } catch (error) {
                    reject(error);
                }
            };

            reader.onerror = () => reject(new Error("Failed to read file."));

            reader.readAsText(file);
        });
    }

    /*
     * Process the given activity log JSON, which is expected to be an array of action items.
     * Each item is processed sequentially.
     * Return a tuple of [calculated portfolio state; map of errors/warnings; whether an error has occurred].
     *
     * In the returned map of errors, the key is the index of the activity item and the value is the error message.
     * If no errors occurred, the map will be empty.
     * If an error has occurred, the processing stops and the calculated portfolio state will be partial.
     * If an error has not occurred, the map will only contain warnings (if any). All data will be successfully processed.
     *
     * Throw in case of a critical error which isn't tied to a specific activity item.
     */
    function processActivityList(activityFileJson) {
        if (!Array.isArray(activityFileJson)) {
            throw new Error("Top-level JSON must be an array.");
        }

        if (activityFileJson.length === 0) {
            throw new Error("Activity JSON is empty.");
        }

        let portfolioObj = new Portfolio();
        let activityErrorMap = new Map();

        let criticalErrorOccurred = false;
        for (const [i, item] of activityFileJson.entries()) {
            try {
                let warnings = processAction(item, portfolioObj);
                if (warnings.length > 0) {
                    activityErrorMap.set(i, `You have ${warnings.length} warning(s): ${warnings.join(' ')}`);
                }
            } catch (error) {
                activityErrorMap.set(i, `Critical error occurred, further processing stopped: ${error.message}`);
                criticalErrorOccurred = true;
                break;
            }
        }

        return [portfolioObj, activityErrorMap, criticalErrorOccurred];
    }

    /*
     * Process a single action item from the activity log, updating the given portfolio state.
     * Return a list of warnings (maybe empty).
     * Throw in case of a critical error in which case the activity item may not be correctly processed.
     */
    function processAction(item, portfolioObj) {
        item = parseActionInputsByNames(item).getOrThrow('Problem parsing input');

        portfolioObj.setSameOrLaterDate(item.date)
            .getOrThrow('Record not in chronological order with previous record');

        // Process the action with a dedicated function
        switch (item.action) {
            case "NewPlatform":
                return processActionNewPlatform(item, portfolioObj);
            case "NewAsset":
                return processActionNewAsset(item, portfolioObj);
            case "Check":
                return processActionCheck(item, portfolioObj);
            case "Deposit":
                return processActionDeposit(item, portfolioObj);
            case "Buy":
                return processActionBuy(item, portfolioObj);
            case "Sell":
                return processActionSell(item, portfolioObj);
            case "Dividend":
                return processActionDividend(item, portfolioObj);
            case "CurrencyConversion":
                return processActionCurrencyConversion(item, portfolioObj);
            case "Transfer":
                return processActionTransfer(item, portfolioObj);
            case "UnspecificAccountingIncomeAction":
                return processActionUnspecificAccountingIncomeAction(item, portfolioObj);
            case "PublicToPrivateShareConversion":
                return processActionPublicToPrivateShareConversion(item, portfolioObj);
            case "Interest":
                return processActionInterest(item, portfolioObj);
            default:
                throw new Error(`Processing for "${item.action}" is not implemented`);
        }
    }

    function processActionPublicToPrivateShareConversion(item, portfolioObj) {
        let warnings = []; // TODO Mark stock as private?

        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        const platform = portfolioObj.getPlatform(item.platform);
        const stockHolding = platform.getStockHolding(item.assetCode);
        if (stockHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${stockHolding.getCurrency()}"`);
        }
        // Validate that the fee value is positive
        if (item.feeValue.lessThanOrEqualTo(0)) {
            warnings.push(`Fee value "${item.feeValue}" is not a positive amount.`);
        }
        // Subtract the fee value from the platform
        warnings = warnings.concat(updateCash(platform, item.currency, item.feeValue.negated(), item.date));

        return warnings;
    }

    /**
     * The unspecific account income action is an event doesn't affect the asset holdings in any meaningful way, but
     * results in an untaxed cash income of the asset's currency - some form of payout by the company. By "untaxed" we
     * don't mean that the income is not taxed, but rather that the tax is not deducted with the payout automatically.
     * An example of such an event could be nominal value reduction - important for the company for accounting purposes,
     * but doesn't affect the held assets directly.
     */
    function processActionUnspecificAccountingIncomeAction(item, portfolioObj) {
        let warnings = [];

        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        const platform = portfolioObj.getPlatform(item.platform);
        const stockHolding = platform.getStockHolding(item.assetCode);
        if (stockHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${stockHolding.getCurrency()}"`);
        }
        if (item.totalValue.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Add the received cash to the platform
        warnings = warnings.concat(updateCash(platform, item.currency, item.totalValue, item.date));

        return warnings;
    }

    function processActionTransfer(item, portfolioObj) {
        let warnings = [];

        if (!portfolioObj.hasPlatform(item.fromPlatform)) {
            throw new Error(`From platform "${item.fromPlatform}" does not exist`);
        }
        if (!portfolioObj.hasPlatform(item.toPlatform)) {
            throw new Error(`To platform "${item.toPlatform}" does not exist`);
        }
        // Validate that the transferred amount is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            throw new Error(`Total value "${item.totalValue}" is not a positive amount`);
        }
        // Validate that the fee value is non-negative
        if (item.feeValue.lessThan(0)) {
            throw new Error(`Fee value "${item.feeValue}" is not a non-negative amount`);
        }
        // Update the cash amount on the from platform
        const fromPlatform = portfolioObj.getPlatform(item.fromPlatform);
        warnings = warnings.concat(updateCash(fromPlatform, item.currency, item.totalValue.negated().plus(item.feeValue), item.date));
        // Update the cash amount on the to platform
        const toPlatform = portfolioObj.getPlatform(item.toPlatform);
        warnings = warnings.concat(updateCash(toPlatform, item.currency, item.totalValue, item.date));
        return warnings;
    }

    function processActionCurrencyConversion(item, portfolioObj) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the from value is positive
        if (item.fromValue.lessThanOrEqualTo(0)) {
            throw new Error(`From value "${item.fromValue}" is not a positive amount`);
        }
        // Validate that the to value is positive
        if (item.toValue.lessThanOrEqualTo(0)) {
            throw new Error(`To value "${item.toValue}" is not a positive amount`);
        }
        if (item.fromToCoefficient.lessThanOrEqualTo(0)) {
            throw new Error(`From-to coefficient "${item.fromToCoefficient}" must be a positive number`);
        }
        // Check that the conversion makes sense
        warnings = warnings.concat(validateCurrencyConversionTransactionValue(item.fromToCoefficient, item.fromValue, item.toValue));

        // Update the cash amounts on the platform
        const platform = portfolioObj.getPlatform(item.platform);

        warnings = warnings.concat(updateCash(platform, item.fromCurrency, item.fromValue.negated(), item.date));
        warnings = warnings.concat(updateCash(platform, item.toCurrency, item.toValue, item.date));
        return warnings;
    }

    function processActionDividend(item, portfolioObj) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        const platform = portfolioObj.getPlatform(item.platform);
        const stockHolding = platform.getStockHolding(item.assetCode);
        if (stockHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${stockHolding.getCurrency()}"`);
        }
        // Validate that the gross value is positive
        if (item.grossValue.lessThanOrEqualTo(0)) {
            throw new Error(`Gross value "${item.grossValue}" is not a positive amount`);
        }
        // Validate that the net value is positive
        if (item.netValue.lessThanOrEqualTo(0)) {
            throw new Error(`Net value "${item.netValue}" is not a positive amount`);
        }
        // Validate that the tax value is positive
        if (item.taxValue.lessThan(0)) {
            throw new Error(`Tax value "${item.taxValue}" is not a non-negative amount`);
        }
        // Validate that the net value is less than or equal to the gross value
        if (item.netValue.greaterThan(item.grossValue)) {
            throw new Error(`Net value "${item.netValue}" cannot be greater than gross value "${item.grossValue}"`);
        }
        // Validate that the tax value is less than or equal to the gross value
        if (item.taxValue.greaterThan(item.grossValue)) {
            throw new Error(`Tax value "${item.taxValue}" cannot be greater than gross value "${item.grossValue}"`);
        }
        // Validate that the net value plus tax value equals gross value
        const expectedGrossValueDecimal = item.netValue.plus(item.taxValue);
        if (!item.grossValue.equals(expectedGrossValueDecimal)) {
            throw new Error(`Gross value ${item.grossValue} does not match the sum of net value and tax value, expected ${expectedGrossValueDecimal}`);
        }

        // Update the cash amount on the platform
        warnings = warnings.concat(updateCash(platform, item.currency, item.netValue, item.date));
        return warnings;
    }

    function processActionInterest(item, portfolioObj) {
        let warnings = [];

        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        const platform = portfolioObj.getPlatform(item.platform);
        const bondHolding = platform.getBondHolding(item.assetCode);
        if (bondHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${bondHolding.getCurrency()}"`);
        }
        // Validate that the gross value is positive
        if (item.grossValue.lessThanOrEqualTo(0)) {
            throw new Error(`Gross value "${item.grossValue}" is not a positive amount`);
        }
        // Validate that the net value is positive
        if (item.netValue.lessThanOrEqualTo(0)) {
            throw new Error(`Net value "${item.netValue}" is not a positive amount`);
        }
        // Validate that the tax value is positive
        if (item.taxValue.lessThan(0)) {
            throw new Error(`Tax value "${item.taxValue}" is not a non-negative amount`);
        }
        // Validate that the net value is less than or equal to the gross value
        if (item.netValue.greaterThan(item.grossValue)) {
            throw new Error(`Net value "${item.netValue}" cannot be greater than gross value "${item.grossValue}"`);
        }
        // Validate that the tax value is less than or equal to the gross value
        if (item.taxValue.greaterThan(item.grossValue)) {
            throw new Error(`Tax value "${item.taxValue}" cannot be greater than gross value "${item.grossValue}"`);
        }
        // Validate that the net value plus tax value equals gross value
        const expectedGrossValueDecimal = item.netValue.plus(item.taxValue);
        if (!item.grossValue.equals(expectedGrossValueDecimal)) {
            throw new Error(`Gross value ${item.grossValue} does not match the sum of net value and tax value, expected ${expectedGrossValueDecimal}`);
        }

        // Update the cash amount on the platform
        warnings = warnings.concat(updateCash(platform, item.currency, item.netValue, item.date));
        return warnings;
    }

    /*
     * Process the "Buy" action of purchasing an asset on a platform.
     */
    function processActionBuy(item, portfolioObj) {
        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Process the asset with a dedicated function
        switch (item.assetType) {
            case "Stock":
                return processActionBuyStock(item, portfolioObj);
            case "IndexFund":
                return processActionBuyIndexFund(item, portfolioObj);
            case "Bond":
                return processActionBuyBond(item, portfolioObj);
            default:
                throw new Error(`Processing of "Buy" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "Sell" action of purchasing an asset on a platform.
     */
    function processActionSell(item, portfolioObj) {
        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Process the asset with a dedicated function
        switch (item.assetType) {
            case "Stock":
                return processActionSellStock(item, portfolioObj);
            case "IndexFund":
                return processActionSellIndexFund(item, portfolioObj);
            default:
                throw new Error(`Processing of "Sell" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "Buy" action for asset type "Stock" of purchasing stock.
     */
    function processActionBuyStock(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        const stockHolding = platform.getStockHolding(item.assetCode);
        // Validate that the share count is positive
        if (item.totalShares.lessThan(0)) {
            throw new Error(`Share count "${item.totalShares}" is not a positive number`);
        }
        // Validate that the currency matches the existing asset currency
        if (stockHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${stockHolding.getCurrency()}"`);
        }
        // Validate that the unit value is positive
        if (item.unitValue.lessThanOrEqualTo(0)) {
            warnings.push(`Unit value "${item.unitValue}" is not a positive amount.`);
        }
        // Validate that the total value is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        warnings = warnings.concat(validateTotalSharesTransactionValue(item.unitValue, item.totalShares, item.totalValue));
        // Subtract the spent cash from the platform
        const spentCash = item.totalValue.plus(item.feeValue).negated();
        warnings = warnings.concat(updateCash(platform, item.currency, spentCash, item.date));
        // Add the shares to the platform
        warnings = warnings.concat(updateStock(platform, item.assetCode, item.totalShares, spentCash, item.date));

        return warnings;
    }

    function validateTotalSharesTransactionValue(unitValue, totalShares, totalValue) {
        let warnings = [];
        let expectedTotalValueDecimal = unitValue.times(totalShares);
        // Check if expected value has more than 2 decimal places, if it does, round it to 2 decimal places
        if (expectedTotalValueDecimal.decimalPlaces() > 2) {
            expectedTotalValueDecimal = expectedTotalValueDecimal.toDecimalPlaces(2);
        }
        if (!totalValue.equals(expectedTotalValueDecimal)) {
            warnings.push(`Total value ${totalValue} does not match the product of share count and unit value, expected ${expectedTotalValueDecimal}.`);
        }
        return warnings;
    }

    function validateCurrencyConversionTransactionValue(fromToCoefficient, fromValue, toValue) {
        let warnings = [];
        let expectedToValue = fromToCoefficient.times(fromValue);
        // Check if expected value has more than 2 decimal places, if it does, round it to 2 decimal places
        if (expectedToValue.decimalPlaces() > 2) {
            expectedToValue = expectedToValue.toDecimalPlaces(2);
        }
        if (!toValue.equals(expectedToValue)) {
            warnings.push(`To value ${toValue} does not match the product of from value ${fromValue} and from-to coefficient ${fromToCoefficient}, expected ${expectedToValue}.`);
        }
        return warnings;
    }

    /*
     * Process the "Buy" action for asset type "Bond" of purchasing a bond.
     */
    function processActionBuyBond(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        const bondHolding = platform.getBondHolding(item.assetCode);
        // Validate that the share count is positive
        if (item.totalShares.lessThan(0)) {
            throw new Error(`Share count "${item.totalShares}" is not a positive number`);
        }
        // Validate that the currency matches the existing asset currency
        if (bondHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${bondHolding.getCurrency()}"`);
        }
        // Validate that the unit value is positive
        if (item.unitValue.lessThanOrEqualTo(0)) {
            warnings.push(`Unit value "${item.unitValue}" is not a positive amount.`);
        }
        // Validate that the total value is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Validate the total value against unit value and share count
        warnings = warnings.concat(validateTotalSharesTransactionValue(item.unitValue, item.totalShares, item.totalValue));
        // Subtract the spent cash from the platform
        const spentCash = item.totalValue.negated();
        warnings = warnings.concat(updateCash(platform, item.currency, spentCash, item.date));
        // Add the shares to the platform
        warnings = warnings.concat(updateBond(platform, item.assetCode, item.totalShares, spentCash, item.date));

        return warnings;
    }

    /*
     * Process the "Buy" action for asset type "IndexFund" of purchasing index fund.
     */
    function processActionBuyIndexFund(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        const indexFundHolding = platform.getIndexFundHolding(item.assetCode);

        // Validate that the currency matches the existing asset currency
        if (indexFundHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${indexFundHolding.getCurrency()}"`);
        }
        // Validate that the total value is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Subtract the spent cash from the platform
        const spentCash = item.totalValue.negated();
        warnings = warnings.concat(updateCash(platform, item.currency, spentCash, item.date));
        // Add the index fund cash to the platform
        warnings = warnings.concat(updateIndexFund(platform, item.assetCode, item.totalValue, spentCash, item.date));
        return warnings;
    }

    /*
     * Process the "Sell" action for asset type "Stock".
     */
    function processActionSellStock(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        const stockHolding = platform.getStockHolding(item.assetCode);
        // Validate that the share count is positive
        if (item.totalShares.lessThan(0)) {
            throw new Error(`Share count "${item.totalShares}" is not a positive number`);
        }
        // Validate that the currency matches the existing asset currency
        if (stockHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${stockHolding.getCurrency()}"`);
        }
        // Validate that the unit value is positive
        if (item.unitValue.lessThanOrEqualTo(0)) {
            warnings.push(`Unit value "${item.unitValue}" is not a positive amount.`);
        }
        // Validate that the total value is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Validate the total value against unit value and share count
        warnings = warnings.concat(validateTotalSharesTransactionValue(item.unitValue, item.totalShares, item.totalValue));
        // Add the acquired cash to the platform
        const acquiredCash = item.totalValue;
        warnings = warnings.concat(updateCash(platform, item.currency, acquiredCash, item.date));
        // Subtract the sold shares from the platform
        warnings = warnings.concat(updateStock(platform, item.assetCode, item.totalShares.negated(), acquiredCash, item.date));

        return warnings;
    }

    /*
     * Process the "Sell" action for asset type "IndexFund".
     */
    function processActionSellIndexFund(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        const indexFundHolding = platform.getIndexFundHolding(item.assetCode);
        // Validate that the currency matches the existing asset currency
        if (indexFundHolding.getCurrency() !== item.currency) {
            throw new Error(`Currency "${item.currency}" does not match the existing asset currency "${indexFundHolding.getCurrency()}"`);
        }
        // Validate that the total value is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            warnings.push(`Total value "${item.totalValue}" is not a positive amount.`);
        }
        // Add the acquired cash to the platform
        const acquiredCash = item.totalValue;
        warnings = warnings.concat(updateCash(platform, item.currency, acquiredCash, item.date));
        // Subtract the index fund cash from the platform
        warnings = warnings.concat(updateIndexFund(platform, item.assetCode, item.totalValue.negated(), acquiredCash, item.date));
        return warnings;
    }

    /*
     * Process the "Deposit" action of adding cash to a platform.
     */
    function processActionDeposit(item, portfolioObj) {
        let warnings = [];

        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Validate that the deposited amount is positive
        if (item.totalValue.lessThanOrEqualTo(0)) {
            throw new Error(`Total value "${item.totalValue}" is not a positive amount`);
        }
        // Update the cash amount on the platform
        const platform = portfolioObj.getPlatform(item.platform);
        warnings = warnings.concat(updateCash(platform, item.currency, item.totalValue, item.date));
        return warnings;
    }

    /*
     * Process the "Check" action of validating an asset's current value.
     */
    function processActionCheck(item, portfolioObj) {
        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Process the asset with a dedicated function
        switch (item.assetType) {
            case "Cash":
                return processActionCheckCash(item, portfolioObj);
            default:
                throw new Error(`Processing of "Check" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "Check" action for asset type "Cash" of validating the current cash amount.
     */
    function processActionCheckCash(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        const cashHolding = platform.getCashHolding(item.currency);

        // Get the cash amount from the platform.
        const cashAmountDecimal = cashHolding.getCurrentValue();

        // Validate the amount
        if (!cashAmountDecimal.equals(item.totalValue)) {
            warnings.push(`Current cash amount for currency "${item.currency}" is ${cashAmountDecimal} but expected ${item.totalValue}`);
        }

        return warnings;
    }

    /*
     * Process the "NewPlatform" action of introducing a new investment platform to the portfolio.
     */
    function processActionNewPlatform(item, portfolioObj) {
        let warnings = [];

        portfolioObj.addPlatform(new Platform(item.platform));

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset to the portfolio.
     */
    function processActionNewAsset(item, portfolioObj) {
        // Validate that the platform exists
        if (!portfolioObj.hasPlatform(item.platform)) {
            throw new Error(`Platform "${item.platform}" does not exist`);
        }
        // Different function per asset type
        switch (item.assetType) {
            case "Stock":
                return processActionNewAssetStock(item, portfolioObj);
            case "IndexFund":
                return processActionNewAssetIndexFund(item, portfolioObj);
            case "Cash":
                return processActionNewAssetCash(item, portfolioObj);
            case "Bond":
                return processActionNewAssetBond(item, portfolioObj);
            default:
                throw new Error(`Processing of "NewAsset" for asset type "${item.assetType}" is not implemented`);
        }
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "Stock" to the portfolio.
     */
    function processActionNewAssetStock(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        platform.addStockHolding(new StockHolding(item.assetCode, item.friendlyName, item.currency));

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "Bond" to the portfolio.
     */
    function processActionNewAssetBond(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        platform.addBondHolding(new BondHolding(item.assetCode, item.friendlyName, item.currency));

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "IndexFund" to the portfolio.
     */
    function processActionNewAssetIndexFund(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        platform.addIndexFundHolding(new IndexFundHolding(item.assetCode, item.friendlyName, item.currency));

        return warnings;
    }

    /*
     * Process the "NewAsset" action of introducing a new asset of type "Cash" to the portfolio.
     */
    function processActionNewAssetCash(item, portfolioObj) {
        let warnings = [];

        const platform = portfolioObj.getPlatform(item.platform);
        platform.addCashHolding(new CashHolding(item.currency));

        return warnings;
    }

    function updateCash(platform, currency, updateDecimal, date) {
        let warnings = [];
        let newAmt = platform.getCashHolding(currency).updateValue(updateDecimal, date);
        if (newAmt.lessThan(0)) {
            warnings.push(`Platform "${platform.getName()}" has become negative in currency "${currency}", new amount is ${newAmt}.`);
        }
        return warnings;
    }

    function updateIndexFund(platform, assetCode, updateDecimal, acquiredCash, date) {
        return platform.getIndexFundHolding(assetCode).updateShares(updateDecimal, acquiredCash, date);
    }

    function updateStock(platform, assetCode, shareCountDecimal, acquiredCash, date) {
        return platform.getStockHolding(assetCode).updateShares(shareCountDecimal, acquiredCash, date);
    }

    function updateBond(platform, assetCode, shareCountDecimal, acquiredCash, date) {
        return platform.getBondHolding(assetCode).updateShares(shareCountDecimal, acquiredCash, date);
    }

    function parseActionInputsByNames(item) {
        if (typeof item !== "object") {
            return new VRes(`Not a JSON object`);
        }

        for (let key of Object.getOwnPropertyNames(item)) {
            if (!ALL_POSSIBLE_JSON_FIELDS.includes(key)) {
                return new VRes(`Unhandled property: "${key}"`);
            }
        }

        // Immediately check action
        if (!item.hasOwnProperty("action")) {
            return new VRes(`Missing required field "action"`);
        }
        if (typeof item.action !== "string") {
            return new VRes(`Field "action" must be a string`);
        }
        if (!Object.getOwnPropertyNames(ACTIONS).includes(item.action)) {
            return new VRes(`Action "${item.action}" is not supported`);
        }
        if (ACTIONS[item.action]) {
            // Immediately check asset type
            if (!item.hasOwnProperty("assetType")) {
                return new VRes(`Missing required field "assetType"`);
            }
            if (typeof item.assetType !== "string") {
                return new VRes(`Field "assetType" must be a string`);
            }
            if (!ASSET_TYPES.includes(item.assetType)) {
                return new VRes(`Asset type "${item.assetType}" is not supported`);
            }
        }

        // Parse inputs
        const parsedInputs = {};
        const expectedFields = getInputsByActionAndAsset(item.action, item.assetType);
        if (expectedFields === undefined) {
            return new VRes(`Action "${item.action}" is not supported for "${item.assetType}"`);
        }
        if (!(expectedFields instanceof Array)) {
            throw new Error(`Expected fields should be an array`);
        }
        for (let key of Object.getOwnPropertyNames(item)) {
            if (!expectedFields.includes(key)) {
                return new VRes(`Property "${key}" is unexpected`); // TODO Should be a warning?
            }
        }

        const optionalFields = ["notes", "feeValue"];
        let vres = new VRes();
        for (let field of expectedFields) {
            if (!ALL_POSSIBLE_JSON_FIELDS.includes(field)) {
                throw new Error(`Invalid expected field`);
            }
            if (!item.hasOwnProperty(field) && !optionalFields.includes(field)) {
                return new VRes(`Missing required field: "${field}"`);
            }
            vres = vres.and(() => parseActionInputByName(field, item[field]))
                .apply((value) => parsedInputs[field] = value);
        }
        return vres.and(() => new VRes(parsedInputs));
    }

    function parseActionInputByName(inputName, inputValue) {
        let validate = () => {
            switch (inputName) {
                case "date":
                    return parseDateInput(inputValue);
                case "action":
                    return validateActionInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                case "platform":
                case "fromPlatform":
                case "toPlatform":
                    return validatePlatformNameInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                case "assetType":
                    return validateAssetTypeInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                case "assetCode":
                    return validateAssetCodeInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                case "currency":
                case "fromCurrency":
                case "toCurrency":
                    return validateCurrencyInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                case "totalValue":
                case "grossValue":
                case "netValue":
                case "taxValue":
                case "fromValue":
                case "toValue":
                case "totalShares":
                    return parseDecimalInput(inputValue, 2);
                case "feeValue":
                    return parseDecimalInput(inputValue, 2, true);
                case "fromToCoefficient":
                    return parseDecimalInput(inputValue, 4);
                case "unitValue":
                    return parseDecimalInput(inputValue, 8);
                case "friendlyName":
                    return validateAssetNameInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                case "notes":
                    return validateNotesInput(inputValue)
                        .and(() => new VRes(inputValue, false));
                default:
                    throw new Error(`Validation not implemented for input name "${inputName}"`);
            }
        };
        return validate().extend(inputName);
    }

    /**
     * Return all the fields that must be present for a given action type and asset type pair.
     * No other fields should be present.
     * Return undefined if the action type and asset type pair are not supported.
     */
    function getInputsByActionAndAsset(action, assetType) {
        switch (action) {
            case "PublicToPrivateShareConversion":
                switch (assetType) {
                    case "Stock":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "feeValue"];
                }
                return undefined;
            case "UnspecificAccountingIncomeAction":
                switch (assetType) {
                    case "Stock":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "totalValue"];
                }
                return undefined;
            case "Transfer":
                switch (assetType) {
                    case "Cash":
                        return ["date", "notes", "action", "fromPlatform", "toPlatform", "assetType", "currency", "totalValue", "feeValue"];
                }
                return undefined;
            case "CurrencyConversion":
                switch (assetType) {
                    case "Cash":
                        return ["date", "notes", "action", "platform", "assetType", "fromCurrency", "toCurrency", "fromValue", "toValue", "fromToCoefficient"];
                }
                return undefined;
            case "Dividend":
                switch (assetType) {
                    case "Stock":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "grossValue", "netValue", "taxValue"];
                }
                return undefined;
            case "Interest":
                switch (assetType) {
                    case "Bond":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "grossValue", "netValue", "taxValue"];
                }
                return undefined;
            case "Buy":
                switch (assetType) {
                    case "Stock":
                    case "Bond":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "totalShares", "unitValue", "totalValue", "feeValue"];
                    case "IndexFund":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "totalValue"];
                }
                return undefined;
            case "Sell":
                switch (assetType) {
                    case "Stock":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "totalShares", "unitValue", "totalValue"];
                    case "IndexFund":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "totalValue"];
                }
                return undefined;
            case "Deposit":
                switch (assetType) {
                    case "Cash":
                        return ["date", "notes", "action", "platform", "assetType", "currency", "totalValue"];
                }
                return undefined;
            case "Check":
                switch (assetType) {
                    case "Cash":
                        return ["date", "notes", "action", "platform", "assetType", "currency", "totalValue"];
                }
                return undefined;
            case "NewPlatform":
                return ["date", "notes", "action", "platform"];
            case "NewAsset":
                switch (assetType) {
                    case "Stock":
                    case "IndexFund":
                    case "Bond":
                        return ["date", "notes", "action", "platform", "assetType", "assetCode", "currency", "friendlyName"];
                    case "Cash":
                        return ["date", "notes", "action", "platform", "assetType", "currency"];
                }
                return undefined;
            default:
                return undefined;
        }
    }

</script>

</body>

</html>
